HTTP协议
客户端连上web 服务器后，若想获得 web 服务器中的某个 web 资源，需遵守一定的通讯格式， HTTP 协议用于定义客户端与 web 服务器通迅的格式。
WEB浏览器与 WEB 服务器之间的一问一答的交互过程必须遵循一定的规则，这个规则就是 HTTP 协议。
HTTP是 hypertext transfer protocol （超文本传输协议）的简写，它是 TCP/IP 协议集中的一个应用层协议，用于定义 WEB 浏览器与WEB 服务器之间交换数据的过程以及数据本身的格式。 
HTTP协议的版本 
HTTP/1.0、 HTTP/1.1
HTTP协议是学习 JavaWEB 开发的基石，不深入了解 HTTP 协议，就不能说掌握了 WEB 开发，更无法管理和维护一些复杂的 WEB 站点。深入理解 HTTP 协议，对管理和维护复杂的 WEB 站点、开发具有特殊用途的 WEB 服务器程序具有直接影响
HTTP 1.0的会话方式
浏览器与WEB 服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与 WEB 服务器都要建立一次单独的连接。 浏览器到 WEB 服务器之间的所有通讯都是完全独立分开的请求和响应对。
 
HTTP 1.1的特点 
在一个TCP 连接上可以传送多个 HTTP 请求和响应  
多个请求和响应过程可以重叠进行
增加了更多的请求头和响应头 
HTTP1.0和 HTTP1.1 的区别
在HTTP1.0 协议中，客户端与 web 服务器建立连接后，只能获得一个 web 资源。
HTTP1.1协议，允许客户端与 web 服务器建立连接后，在一个连接上获取多个 web 资源。
HTTP请求的细节——请求行
请求行中的GET 称之为请求方式，请求方式有：
POST、 GET 、 HEAD 、 OPTIONS 、 DELETE 、 TRACE 、 PUT
常用的有： GET 、  POST
用户如没有设置，默认情况下浏览器向服务器发送的都是get 请求，例如在浏览器直接输地址访问，点超链接访问等都是 get ，用户如想把请求方式改为 post ，可通过更改表单的提交方式实现。
不管POST 或 GET ，都用于向服务器请求某个 WEB 资源，这两种方式的区别主要表现在数据传递上：
如请求方式为GET 方式，则可以在请求的 URL 地址后以 ? 的形式带上交给服务器的数据，多个数据之间以 & 进行分隔，例如：
GET /mail/1.html?name=abc&password=xyz HTTP/1.1
GET方式的特点：在 URL 地址后附带的参数是有限制的，其数据容量通常不能超过 1K 。
如请求方式为POST 方式，则可以在请求的实体内容中向服务器发送数据， Post 方式的特点：传送的数据量无限制。
HTTP请求的细节——消息头
用于HTTP 请求中的常用头
Accept: text/html,image/*    
Accept-Charset: ISO-8859-1
Accept-Encoding: gzip,compress
Accept-Language: en-us,zh-cn 
Host: www.it315.org:80
If-Modified-Since: Fri, 11 Dec 2015 18:23:51 GMT
Referer: http://www.it315.org/index.jsp
User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)
Cookie
Connection: close/Keep-Alive   
Date: Fri, 11 Dec 2015 18:23:51 GMT

HTTP响应的细节——状态行
状态行
格式： HTTP 版本号　状态码　原因叙述 <CRLF>
举例：HTTP/1.1 200 OK
状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5 类，如下所示：
响应状态码à典型情况

200（正常） 
表示一切正常，返回的是正常请求结果。
302/307（临时重定向）
指出被请求的文档已被临时移动到别处，此文档的新的URL 在 Location 响应头中给出。
304（未修改）
表示客户机缓存的版本是最新的，客户机应该继续使用它。
403（禁止） 
服务器理解客户端请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置所致。 
404（找不到） 
服务器上不存在客户机所请求的资源。
500（内部服务器错误） 
服务器端的CGI 、 ASP 、 JSP 等程序发生错误。

HTTP响应细节——常用响应头

HTTP请求中的常用响应头
Location: http://www.it315.org/index.jsp 
Server:apache tomcat
Content-Encoding: gzip 
Content-Length: 80 
Content-Language: zh-cn 
Content-Type: text/html; charset=GB2312 
Last-Modified: Fri, 11 Dec 2015 18:23:51 GMT
Refresh: 1;url=http://www.it315.org
Content-Disposition: attachment; filename=aaa.zip
Transfer-Encoding: chunked  
Set-Cookie:SS=Q0=5Lb_nQ; path=/search
ETag: W/"7777-1242234904000"
Expires: -1
Cache-Control: no-cache  
Pragma: no-cache   
Connection: close/Keep-Alive   
Date: Fri, 11 Dec 2015 18:23:51 GMT

OSI （ Open System Interconnect ），即开放式系统互联。 一般都叫 OSI 参考模型，是 ISO （国际标准化组织）组织在 1985 年研究的网络互联模型。该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即 ISO 开放系统互连参考模型。在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。
ISO 为了更好的使网络应用更为普及，就推出了 OSI 参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。提供各种网络服务功能的计算机网络系统是非常复杂的。根据分而治之的原则， ISO 将整个通信功能划分为七个层次，划分原则是：
    （ 1 ）网路中各节点都有相同的层次；
    （ 2 ）不同节点的同等层具有相同的功能；
    （ 3 ）同一节点内相邻层之间通过接口通信；
    （ 4 ）每一层使用下层提供的服务，并向其上层提供服务；
    （ 5 ）不同节点的同等层按照协议实现对等层之间的通信。
 
    分层的好处是利用层次结构可以把开放系统的信息交换问题分解到一系列容易控制的软硬件模块－层中，而各层可以根据需要独立进行修改或扩充功能，同时，有利于个不同制造厂家的设备互连，也有利于大家学习、理解数据通讯网络。
               OSI 参考模型中不同层完成不同的功能，各层相互配合通过标准的接口进行通信。
第 7 层应用层： OSI 中的最高层。 为特定类型的网络应用提供了访问 OSI 环境的手段。应用层确定进程之间通信的性质，以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远程操作，而且还要作为应用进程的用户代理，来完成一些为进行信息交换所必需的功能。它包括：文件传送访问和管理 FTAM 、虚拟终端 VT 、事务处理 TP 、远程数据库访问 RDA 、制造报文规范 MMS 、目录服务DS 等协议；应用层能与应用程序界面沟通，以达到展示给用户的目的。 在此常见的协议有 :HTTP ， HTTPS ， FTP ， TELNET ，SSH ， SMTP ， POP3 等。
第 6 层表示层：主要用于处理两个通信系统中交换信息的表示方式。 为上层用户解决用户信息的语法问题。它包括数据格式交换、数据加密与解密、数据压缩与终端类型的转换。
第 5 层会话层：在两个节点之间建立端连接。 为端系统的应用程序之间提供了对话控制机制。此服务包括建立连接是以全双工还是以半双工的方式进行设置，尽管可以在层 4 中处理双工方式 ；会话层管理登入和注销过程。它具体管理两个用户和进程之间的对话。如果在某一时刻只允许一个用户执行一项特定的操作，会话层协议就会管理这些操作，如阻止两个用户同时更新数据库中的同一组数据。
第 4 层传输层：—常规数据递送－面向连接或无连接。 为会话层用户提供一个端到端的可靠、透明和优化的数据传输服务机制。包括全双工或半双工、流控制和错误恢复服务；传输层把消息分成若干个分组，并在接收端对它们进行重组。不同的分组可以通过不同的连接传送到主机。这样既能获得较高的带宽，又不影响会话层。在建立连接时传输层可以请求服务质量，该服务质量指定可接受的误码率、延迟量、安全性等参数，还可以实现基于端到端的流量控制功能。
第 3 层网络层：本层通过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。 它包括通过互连网络来路由和中继数据 ；除了选择路由之外，网络层还负责建立和维护连接，控制网络上的拥塞以及在必要的时候生成计费信息。常用设备有交换机；
第 2 层数据链路层：在此层将数据分帧，并处理流控制。 屏蔽物理层，为网络层提供一个数据链路的连接，在一条有可能出差错的物理连接上，进行几乎无差错的数据传输（差错控制）。本层指定拓扑结构并提供硬件寻址。常用设备有网卡、网桥、交换机；
第 1 层物理层：处于 OSI 参考模型的最底层。 物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以便透明的传送比特流。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。
数据发送时，从第七层传到第一层，接收数据则相反。
上三层总称应用层，用来控制软件方面。下四层总称数据流层，用来管理硬件。除了物理层之外其他层都是用软件实现的。
数据在发至数据流层的时候将被拆分。
在传输层的数据叫段，网络层叫包，数据链路层叫帧，物理层叫比特流，这样的叫法叫 PDU （协议数据单元）
各层功能详述
(1) 物理层 (Physical Layer)
物理层是 OSI 参考模型的最低层，它利用传输介质为数据链路层提供物理连接。它主要关心的是通过物理链路从一个节点向另一个节点传送比特流，物理链路可能是铜线、卫星、微波或其他的通讯媒介。它关心的问题有：多少伏电压代表 1 ？多少伏电压代表 0 ？时钟速率是多少？采用全双工还是半双工传输？总的来说物理层关心的是链路的机械、电气、功能和规程特性。
(2) 数据链路层 (Data Link Layer)
数据链路层是为网络层提供服务的，解决两个相邻结点之间的通信问题，传送的协议数据单元称为数据帧。
数据帧中包含物理地址（又称 MAC 地址）、控制码、数据及校验码等信息。该层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路转换成对网络层来说无差错的数据链路。
此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞。
(3) 网络层 (Network Layer)
网络层是为传输层提供服务的，传送的协议数据单元称为数据包或分组。该层的主要作用是解决如何使数据包通过各结点传送的问题，即通过路径选择算法（路由）将数据包送到目的地。另外，为避免通信子网中出现过多的数据包而造成网络阻塞，需要对流入的数据包数量进行控制（拥塞控制）。当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。
(4) 传输层 (Transport Layer)
传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。
传输层传送的协议数据单元称为段或报文。
(5) 会话层 (Session Layer)
会话层主要功能是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。会话层得名的原因是它很类似于两个实体间的会话概念。例如，一个交互的用户会话以登录到计算机开始，以注销结束。
(6) 表示层 (Presentation Layer)
表示层处理流经结点的数据编码的表示方式问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据表示格式转换成网络通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。
(7) 应用层 (Application Layer)
应用层是 OSI 参考模型的最高层，是用户与网络的接口。该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。
数据封装过程：
每层封装后的数据单元的叫法不同，在应用层、表示层、会话层的协议数据单元统称为data（数据），在传输层协议数据单元称为segment（数据段），在网络层称为packet（数据包），数据链路层协议数据单元称为frame（数据帧），在物理层叫做bits（比特流）。

当数据到达接收端时，每一层读取相应的控制信息根据控制信息中的内容向上层传递数据单元，在向上层传递之前去掉本层的控制头部信息和尾部信息（如果有的话）。此过程叫做解封装。
这个过程逐层执行直至将对端应用层产生的数据发送给本端的相应的应用进程。
以用户浏览网站为例说明数据的封装、解封装过程。
当用户输入要浏览的网站信息后就由应用层产生相关的数据，通过表示层转换成为计算机可识别的ASCII码，再由会话层产生相应的主机进程传给传输层。传输层将以上信息作为数据并加上相应的端口号信息以便目的主机辨别此报文，得知具体应由本机的哪个任务来处理；在网络层加上IP地址使报文能确认应到达具体某个主机，再在数据链路层加上MAC地址，转成bit流信息，从而在网络上传输。报文在网络上被各主机接收，通过检查报文的目的MAC地址判断是否是自己需要处理的报文，如果发现MAC地址与自己不一致，则丢弃该报文，一致就去掉MAC信息送给网络层判断其IP地址；然后根据报文的目的端口号确定是由本机的哪个进程来处理，这就是报文的解封装过程。
7 应用层：老板
6 表示层：相当于公司中演示稿老板、替老板写信的助理
工作比喻
5 会话层：相当于公司中收寄信、写信封与拆信封的秘书
4 传输层：相当于公司中跑邮局的送信职员
3 网络层：相当于邮局中的排序工人
2 数据链路层：相当于邮局中的装拆箱工人
        1 物理层：相当于邮局中的搬运工人
OSI是一个定义良好的协议规范集，并有许多可选部分完成类似的任务。 
它定义了开放系统的层次结构、层次之间的相互关系以及各层所包括的可能的任务。是作为一个框架来协调和组织各层所提供的服务。 
OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。 即OSI参考模型并不是一个标准，而是一个在制定标准时所使用的概念性框架。

Hadoop框架使用Mapper将数据处理成一个<key,value>键值对，再网络节点间对其进行整理(shuffle)，然后使用Reducer处理数据并进行最终输出。    在上述过程中，我们看到至少两个性能瓶颈：（引用）
1.	如果我们有10亿个数据，Mapper会生成10亿个键值对在网络间进行传输，但如果我们只是对数据求最大值，那么很明显的Mapper只需要输出它所知道的最大值即可。这样做不仅可以减轻网络压力，同样也可以大幅度提高程序效率。
2.	使用专利中的国家一项来阐述数据倾斜这个定义。这样的数据远远不是一致性的或者说平衡分布的，由于大多数专利的国家都属于美国，这样不仅Mapper中的键值对、中间阶段(shuffle)的键值对等，大多数的键值对最终会聚集于一个单一的Reducer之上，压倒这个Reducer，从而大大降低程序的性能。
目标：
Mapreduce中的Combiner就是为了避免map任务和reduce任务之间的数据传输而设置的，Hadoop允许用户针对map task的输出指定一个合并函数。即为了减少传输到Reduce中的数据量。它主要是为了削减Mapper的输出从而减少网络带宽和Reducer之上的负载。
 
数据格式转换：
map: (K1, V1) → list(K2,V2) 
combine: (K2, list(V2)) → list(K3, V3) 
reduce: (K3, list(V3)) → list(K4, V4)
注意：combine的输入和reduce的完全一致，输出和map的完全一致
 
使用注意：
对于Combiner有几点需要说明的是：
1）有很多人认为这个combiner和map输出的数据合并是一个过程，其实不然，map输出的数据合并只会产生在有数据spill出的时候，即进行merge操作。
2）与mapper与reducer不同的是，combiner没有默认的实现，需要显式的设置在conf中才有作用。
3）并不是所有的job都适用combiner，只有操作满足结合律的才可设置combiner。combine操作类似于：opt(opt(1, 2, 3), opt(4, 5, 6))。如果opt为求和、求最大值的话，可以使用，但是如果是求中值的话，不适用。
4）一般来说，combiner和reducer它们俩进行同样的操作。
但是：特别值得注意的一点，一个 combiner 只是处理一个结点中的 的输出，而不能享受像 reduce 一样的输入（经过了 shuffle 阶段的数据），这点非常关键。
Combiner： 前面展示的流水线忽略了一个可以优化MapReduce作业所使用带宽的步骤，这个过程叫Combiner，它在Mapper之后Reducer之前运行。Combiner是可选的，如果这个过程适合于你的作业，Combiner实例会在每一个运行map任务的节点上运行。Combiner会接收特定节点上的Mapper实例的输出作为输入，接着Combiner的输出会被发送到Reducer那里，而不是发送Mapper的输出。Combiner是一个“迷你reduce”过程， 它只处理单台机器生成的数据（特别重要，作者在做一个矩阵乘法的时候，没有领会到这点，把它当成一个完全的reduce的输入数据来处理，结果出错。）。 
词频统计是一个可以展示Combiner的用处的基础例子，上面的词频统计程序为每一个它看到的词生成了一个（word，1）键值对。所以如果在同一个文档内“cat”出现了3次，（”cat”，1）键值对会被生成3次，这些键值对会被送到Reducer那里。通过使用Combiner，这些键值对可以被压缩为一个送往Reducer的键值对（”cat”，3）。现在每一个节点针对每一个词只会发送一个值到reducer，大大减少了shuffle过程所需要的带宽并加速了作业的执行。这里面最爽的就是我们不用写任何额外的代码就可以享用此功能！如果你的reduce是可交换及可组合的，那么它也就可以作为一个Combiner。

（1）对于public修饰符，它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。
（2）对于protected修饰符，它主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。
（3）对于default来说，有点的时候也成为friendly（友员），它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。
（4）对于private来说，它的访问权限仅限于类的内部，是一种封装的体现，例如，大多数的成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。


如需在表中添加列，请使用下列语法:
ALTER TABLE table_name
ADD column_name datatype
要删除表中的列，请使用下列语法：
ALTER TABLE table_name 
DROP COLUMN column_name
删除列可以省略column，添加列必须说明数据类型

数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括日志文件，数据库后备副本

